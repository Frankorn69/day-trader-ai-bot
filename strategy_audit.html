<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Audit üïµÔ∏è‚Äç‚ôÄÔ∏è</title>
    <style>
        body {
            background: #121212;
            color: #e0e0e0;
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 20px;
        }

        h1 {
            margin-bottom: 10px;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
        }

        .stat-box {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #bb86fc;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
        }

        #chart-container {
            width: 100%;
            height: 600px;
            border: 1px solid #333;
            border-radius: 8px;
        }

        .legend {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
        }
    </style>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <!-- Reuse Bot Logic for Indicators -->
    <script src="bot.js"></script>
</head>

<body>
    <h1>üïµÔ∏è‚Äç‚ôÄÔ∏è Strategy Audit: Trend-Momentum Pullback</h1>
    <p>Analyzing historical data for "Near Misses" (too strict RSI) and "Whipsaws" (too tight SL).</p>

    <div class="stats">
        <div class="stat-box">
            <div class="stat-value" id="count-miss">0</div>
            <div class="stat-label">Near Misses (RSI 50-55)</div>
        </div>
        <div class="stat-box">
            <div class="stat-value" id="count-whipsaw">0</div>
            <div class="stat-label">Whipsaws (SL then TP)</div>
        </div>
    </div>

    <div id="chart-container"></div>
    <div class="legend">
        üü£ <strong>Arrow Up/Down:</strong> Near Miss (Missed Entry) |
        üü£ <strong>X:</strong> Whipsaw (Premature Stop Out)
    </div>

    <script>
        // --- Configuration ---
        const CONFIG = {
            emaPeriod: 100,
            rsiPeriod: 14,
            atrPeriod: 14,
            rsiStrict: 50,
            rsiRelaxed: 55, // "Near Miss" range: 50-55
            slMult: 1.5,
            tpMult: 3.0
        };

        // --- Chart Setup ---
        const chartContainer = document.getElementById('chart-container');
        const chart = LightweightCharts.createChart(chartContainer, {
            layout: { background: { color: '#121212' }, textColor: '#d1d4dc' },
            grid: { vertLines: { color: '#2B2B43' }, horzLines: { color: '#2B2B43' } },
            timeScale: { timeVisible: true, secondsVisible: false },
        });
        const candleSeries = chart.addCandlestickSeries();

        // --- Data Fetching ---
        async function fetchData() {
            try {
                // Fetch 1000 candles (Bybit Spot)
                const response = await fetch('https://api.bybit.com/v5/market/kline?category=spot&symbol=BTCUSDT&interval=15&limit=1000');
                const json = await response.json();

                if (json.retCode !== 0) throw new Error(json.retMsg);

                const candles = json.result.list.map(d => ({
                    time: parseInt(d[0]) / 1000,
                    open: parseFloat(d[1]),
                    high: parseFloat(d[2]),
                    low: parseFloat(d[3]),
                    close: parseFloat(d[4]),
                    volume: parseFloat(d[5])
                })).sort((a, b) => a.time - b.time);

                return candles;
            } catch (e) {
                console.error("Error fetching data:", e);
                alert("Failed to fetch data from Bybit.");
                return [];
            }
        }

        // --- Audit Logic ---
        function runAudit(candles) {
            const markers = [];
            let missCount = 0;
            let whipsawCount = 0;

            // Calculate Indicators
            const ema = Indicators.ema(candles, CONFIG.emaPeriod);
            const rsi = Indicators.rsi(candles, CONFIG.rsiPeriod);
            const atr = Indicators.atr(candles, CONFIG.atrPeriod);
            const vwap = Indicators.vwap(candles);

            // We need all indicators to be present
            const startIndex = 100;

            for (let i = startIndex; i < candles.length - 20; i++) { // Leave room for forward look
                const c = candles[i];
                const prevC = candles[i - 1];

                const curEma = ema[i];
                const curRsi = rsi[i];
                const curAtr = atr[i];
                const curVwap = vwap[i];

                // 1. Detect "Near Miss" (Long only for simplicity demo)
                // Trend is UP (Price > EMA & VWAP)
                if (c.close > curEma && c.close > curVwap) {
                    // RSI is in "Frustration Zone" (50 < RSI < 55)
                    // And it starts going up (Pivot)
                    if (curRsi >= CONFIG.rsiStrict && curRsi <= CONFIG.rsiRelaxed) {
                        // Check if this was a local bottom (prev RSI was higher, next RSI is higher)
                        // Simple check: Just flagging candles in the zone for now
                        if (rsi[i - 1] > curRsi && rsi[i + 1] > curRsi) {
                            markers.push({
                                time: c.time,
                                position: 'belowBar',
                                color: '#800080',
                                shape: 'arrowUp',
                                text: `Near Miss (RSI ${curRsi.toFixed(1)})`
                            });
                            missCount++;
                        }
                    }
                }

                // 2. Detect "Whipsaw" (Simulate a trade)
                // Assume we took a standard trade here
                const isLongEntry = (c.close > curEma && c.close > curVwap && curRsi < CONFIG.rsiStrict && c.close > prevC.high);

                if (isLongEntry) {
                    const entryPrice = c.close;
                    const sl = entryPrice - (CONFIG.slMult * curAtr);
                    const tp = entryPrice + (CONFIG.tpMult * curAtr);

                    // Look forward 20 bars
                    let hitSl = false;
                    let hitTpAfterSl = false;

                    for (let j = 1; j <= 20; j++) {
                        const future = candles[i + j];
                        if (!future) break;

                        if (!hitSl && future.low <= sl) {
                            hitSl = true;
                            // Check if it would have hit TP later
                            for (let k = j + 1; k <= 20; k++) {
                                const future2 = candles[i + k];
                                if (!future2) break;
                                if (future2.high >= tp) {
                                    hitTpAfterSl = true;
                                    break;
                                }
                            }
                            break; // Stop checking this trade
                        }
                        if (future.high >= tp) break; // TP hit first, good trade
                    }

                    if (hitSl && hitTpAfterSl) {
                        markers.push({
                            time: c.time,
                            position: 'aboveBar',
                            color: '#800080',
                            shape: 'arrowDown', // Marking the entry that failed
                            text: 'Whipsaw Stop'
                        });
                        whipsawCount++;
                    }
                }
            }

            document.getElementById('count-miss').innerText = missCount;
            document.getElementById('count-whipsaw').innerText = whipsawCount;
            return markers;
        }

        // --- Main ---
        (async () => {
            const candles = await fetchData();
            if (candles.length === 0) return;

            candleSeries.setData(candles);

            const markers = runAudit(candles);
            candleSeries.setMarkers(markers);

            chart.timeScale().fitContent();
        })();

        // Resize
        window.addEventListener('resize', () => {
            chart.resize(chartContainer.clientWidth, chartContainer.clientHeight);
        });
    </script>
</body>

</html>